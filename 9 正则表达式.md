### 正则表达式模式

模式字符串使用特殊的语法来表示一个正则表达式：

> 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。
>
> 多数字母和数字前加一个反斜杠时会拥有不同的含义。
>
> 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
>
> 反斜杠本身需要使用反斜杠转义。

#### 简单模式：

##### 匹配字符

大多数字母和字符只会匹配自己。 例如，正则表达式 `'test'` 将完全匹配字符串 `test` 。 （你可以启用一个不区分大小写的模式，让这个正则匹配 `Test` 或 `TEST`）

一些字符是特殊的 *metacharacters* （元字符），并且不匹配自己。 相反，它们表示应该匹配一些与众不同的东西，或者通过重复它们或改变它们的含义来影响正则的其他部分。

下面是元字符的完整列表：

```python
 .  ^ $ * + ? { } [ ] ( ) \ |
```

**元字符 `[`和`]`**

`[`和`]`用于指定字符类，它是你希望匹配的一组字符。可以单独列出字符，也可以通过给出两个字符并用 `'-'` 标记将它们分开来表示一系列字符。 例如， `[abc]` 将匹配任何字符 `a`、 `b` 或 `c` ；这与 `[a-c]` 相同，它使用一个范围来表示同一组字符。 如果你只想匹配小写字母，你的正则是 `[a-z]` 。

字符类中的元字符不生效。例如：`[akm$]`将匹配`'a'`，`'k'`，`'m' ` 或 `'$'` 中的任意字符；`'$'` 是一个元字符，但在字符类中它被剥夺了特殊性。

**元字符 `^` **

`^`可以让你匹配设置的字符类中没有列出的字符。这通过包含一个`^` 作为该类的第一个字符来表示。例如，`[^5]`  将匹配除 `'5'` 之外的任何字符。如果该元字符出现在字符类的其他位置，则它没有特殊含义。

**元字符 `\`**

与 Python 字符串文字一样，反斜杠后面可以跟各种字符，以指示各种特殊序列。它也用于转义所有元字符，因此您仍然可以在模式中匹配它们；例如，如果你需要匹配 `[` 或 `\`，你可以在它们前面加一个反斜杠来移除它们的特殊含义。

```python
'\['  '\\'
```

部分特殊序列列表：

- `\d` ：匹配任何10进制数字；等价与 类`[0-9]`

- `\D` ：匹配任何非数字字符；等价于类 `[^0-9]`

- `\s` ：匹配任何空白字符；这等价于类 `[\t\n\r\f\v]`

- `\S` ：匹配任何非空白字符；相当于类 `[^\t\n\r\f\v]`

- `\w` ：匹配任何字母数字字符；相当于类 `[a-zA-Z0-9]`

- `\W` ：匹配任何非字母数字字符；相当于类 `[^a-zA-Z0-9]`

这些序列可以包含在字符类中。 例如，`[\s,.]` 是一个匹配任何空格字符的字符类或者 `','` ，或 `'.'`。

**元字符 `.`**

它匹配除换行符之外的任何内容，并且有一个可选模式（re.DOTALL）甚至可以匹配换行符。`.` 常用于你想匹配任何字符的地方。

#### 重复

`*` 与字面字符 `'*'` 不匹配；它指定前一个字符可以匹配零次或多次，而不是恰好一次。

例如，`ca*t` 将匹配 `'ct'`,`'cat'`,`'caat'`,`'caaat'` 等等。

类似 `*` 这样的重复是 *贪婪的*；当重复正则时，匹配引擎将尝试尽可能多地重复它。 如果模式的后续部分不匹配，则匹配引擎将回退并以较少的重复次数再次尝试。

例如， 让我们考虑表达式 `a[bcd]*b`。 这个正则匹配字母 `'a'`，类 `[bcd]` 中的零或多个字母，最后以 `'b'` 结尾。 现在想象一下这个正则与字符串 `'abcbd'` 匹配。



| 步骤 | 匹配    | 解释                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | `a`     | 正则中的 `a` 匹配。                                          |
| 2    | `abcbd` | 引擎尽可能多地匹配 `[bcd]*` ，直到字符串结束。               |
| 3    | *失败*  | 引擎尝试匹配 `b` ，但是当前位置位于字符串结束，所以匹配失败。 |
| 4    | `abcb`  | 回退一次，`[bcd]*` 少匹配一个字符。                          |
| 5    | *失败*  | 再次尝试匹配 `b` ， 但是当前位置是最后一个字符 `'d'` 。      |
| 6    | `abc`   | 再次回退，所以 `[bcd]*` 只匹配 `bc` 。                       |
| 6    | `abcb`  | 再试一次 `b` 。 这次当前位置的字符是 `'b'` ，所以它成功了。  |

另一个重复的元字符是 `+` ，它匹配一次或多次，与 `*` 相比，`+` 至少需要匹配一次才算成功，而 `*` 可以不匹配到。例如，`ca+t`，不会匹配到 `'ct'` 。

`?` 字符匹配一次或零次，你可以把它想象成是可选的。 例如，`home-?brew` 只能匹配 `'homebrew'` 或 `'home-brew'`。

最复杂的重复限定符是 `{m,n}` ，其中 *m* 和 *n* 是十进制整数，这个限定符表示至少重复 *m* 次，最多重复 *n* 次。

例如， `a/{1,3}b` 将匹配  `a/b`，`a//b`，`a///b`。

> 你可以省略 *m* 或 *n*; 在这种情况下，将假定缺失值的合理值。 省略 *m* 被解释为 0 下限，而省略 *n* 则为无穷大的上限。

其他三个限定符都可以通过这种方法表示，`{0,}` 与 `*` 相同，`{1,}` 与 `+` 相同，`{0,1}` 与 `?` 相同。

### 使用正则表达式

`re` 模块提供了正则表达式引擎的接口，允许你将正则编译为对象，然后用它们进行匹配。

#### 编译正则表达式

正则表达式被编译成模式对象，模式对象具有各种操作的方法，例如搜索模式匹配或执行字符串替换。、

```python
import re
p = re.compile('a/{2,5}b')
```

`re.compile()`也接受一个可选的 *flags* 参数，用于启用各种特殊功能和语法变体。

```python
p1 = re.compile('ab*', re.IGNORECASE)
```

#### 反斜杠灾难







#### 应用匹配

 模式对象的方法和属性：

| 方法 / 属性  | 目的                                                         |
| :----------- | :----------------------------------------------------------- |
| `match()`    | 确定正则是否从字符串的开头匹配。                             |
| `search()`   | 扫描字符串，查找此正则匹配的任何位置。                       |
| `findall()`  | 找到正则匹配的所有子字符串，并将它们作为列表返回。           |
| `finditer()` | 找到正则匹配的所有子字符串，并将它们返回为一个 iterator（迭代器）。 |

如果没有找到匹配， `match() `和 `search()` 返回 `None `。如果它们成功， 一个 匹配对象 实例将被返回，包含匹配相关的信息：起始和终结位置、匹配的子串以及其它。

导入 `re` 模块，编译一个正则。

```python
import re
p = re.compile('a/{2,5}b')
```

尝试匹配字符串。

```python
m = p.match('')
print(m)
#None
```

空字符串不匹配，这种情况下 `match()` 返回 None

```python
m = p.match('a///b')
print(m)
# <re.Match object; span=(0, 5), match='a///b'>
```

如果匹配成功，`match()` 将返回一个匹配对象。

现在你可以检查 匹配对象 以获取有关匹配字符串的信息。 匹配对象实例也有几个方法和属性；最重要的是：

| 方法 / 属性 | 目的                                 |
| :---------- | :----------------------------------- |
| `group()`   | 返回正则匹配的字符串                 |
| `start()`   | 返回匹配的开始位置                   |
| `end()`     | 返回匹配的结束位置                   |
| `span()`    | 返回包含匹配 (start, end) 位置的元组 |

```python
m = p.match('a///b')
print(m.group())
print(m.start())
print(m.end())
print(m.span())
#a///b
#0
#5
#(0, 5)
```

`group()` 返回正则匹配的子字符串。 `start()` 和` end() `返回匹配的起始和结束索引。 `span() `在单个元组中返回开始和结束索引。

由于 `match()` 方法只检查正则是否在字符串的开头匹配，所以 `start()` 将始终为零。 但是，模式的 `search()` 方法会扫描字符串，因此在这种情况下匹配可能不会从零开始。

```python
m = p.search('aaba////ba/////ba//bab')
print(m.group())
print(m.start())
print(m.end())
print(m.span())
#a////b
#3
#9
#(3, 9)
```

有两种方法返回模式的所有匹配项：`findall()` 返回匹配字符串的列表：

```python
m = p.findall('aaba////ba/////ba//bab')
print(m)
#['a////b', 'a/////b', 'a//b']
```

`finditer()` 方法将返回一个匹配对象的序列。是一个可迭代对象。

```python
iterator = p.finditer('aaba////ba/////ba//bab')
for m in iterator:
		print(m)
    print(m.group(), m.start(), m.end(), m.span())
#<re.Match object; span=(3, 9), match='a////b'>
#a////b 3 9 (3, 9)
#<re.Match object; span=(9, 16), match='a/////b'>
#a/////b 9 16 (9, 16)
#<re.Match object; span=(16, 20), match='a//b'>
#a//b 16 20 (16, 20)
```

#### 模块级别函数

你不必创建模式对象并调用其方法；re 模块还提供了顶级函数 `match()`，`search()`，`findall()`，`sub() `等等。 这些函数采用与相应模式方法相同的参数，并将正则字符串作为第一个参数添加，并仍然返回 None 或 匹配对象 实例。

```python
m = re.findall('ab*', 'ababbabbbabbba')
print(m)
#['ab', 'abb', 'abbb', 'abbb', 'a']
```

#### 编译标志

编译标志允许你修改正则表达式的工作方式。 标志在 `re`模块中有两个名称，长名称如 `IGNORECASE` 和一个简短的单字母形式，例如 `I`。 （如果你熟悉 Perl 的模式修饰符，则单字母形式使用和其相同的字母；例如， `re.VERBOSE`的缩写形式为 `re.X`。）多个标志可以 通过按位或运算来指定它们；例如，`re.I | re.M` 设置 `I` 和 `M` 标志。

可用标志表：

| 标志                         | 意义                                                         |
| :--------------------------- | :----------------------------------------------------------- |
| `ASCII`, `A`                 | 使几个转义如 `\w`、`\b`、`\s` 和 `\d` 匹配仅与具有相应特征属性的 ASCII 字符匹配。 |
| `DOTALL`, `S`                | 使 `.` 匹配任何字符，包括换行符。                            |
| `IGNORECASE`, `I`            | 进行大小写不敏感匹配。                                       |
| `LOCALE`, `L`                | 进行区域设置感知匹配。                                       |
| `MULTILINE`, `M`             | 多行匹配，影响 `^` 和 `$`。                                  |
| `VERBOSE`, `X` （为 '扩展'） | 启用详细的正则，可以更清晰，更容易理解。                     |

**`I`**

**`IGNORECASE`**

执行不区分大小写的匹配；字符类和字面字符串将通过忽略大小写来匹配字母。 例如，`[A-Z]` 也匹配小写字母。 除非使用 `ASCII` 标志来禁用非ASCII匹配，否则完全 Unicode 匹配也有效。 当 Unicode 模式 `[a-z]` 或 `[A-Z]` 与 `IGNORECASE` 标志结合使用时，它们将匹配 52 个 ASCII 字母和 4 个额外的非 ASCII 字母：'İ' (U+0130，拉丁大写字母 I，带上面的点)，'ı' (U+0131，拉丁文小写字母无点 i)，'s' (U+017F，拉丁文小写字母长 s) 和'K' (U+212A，开尔文符号)。 `Spam` 将匹配 `'Spam'`，`'spam'`，`'spAM'` 或 `'ſpam'` (后者仅在 Unicode 模式下匹配)。 此小写不考虑当前区域设置；如果你还设置了 `LOCALE` 标志，则将考虑。

**`L`**

**`LOCALE`**

使 `\w`、`\W`、`\b`、`\B` 和大小写敏感匹配依赖于当前区域而不是 Unicode 数据库。

区域设置是 C 库的一个功能，旨在帮助编写考虑到语言差异的程序。例如，如果你正在处理编码的法语文本，那么你希望能够编写 `\w+` 来匹配单词，但 `\w` 只匹配字符类 `[A-Za-z]` 字节模式；它不会匹配对应于 `é` 或 `ç` 的字节。如果你的系统配置正确并且选择了法语区域设置，某些C函数将告诉程序对应于 `é` 的字节也应该被视为字母。在编译正则表达式时设置 `LOCALE` 标志将导致生成的编译对象将这些C函数用于 `\w`；这比较慢，但也可以使 `\w+` 匹配你所期望的法语单词。在 Python 3 中不鼓励使用此标志，因为语言环境机制非常不可靠，它一次只处理一个“文化”，它只适用于 8 位语言环境。默认情况下，Python 3 中已经为 Unicode（str）模式启用了 Unicode 匹配，并且它能够处理不同的区域/语言。

**`M`**

**`MULTILINE`**

通常 `^` 只匹配字符串的开头，而 `$` 只匹配字符串的结尾，紧接在字符串末尾的换行符（如果有的话）之前。 当指定了这个标志时，`^` 匹配字符串的开头和字符串中每一行的开头，紧跟在每个换行符之后。 类似地，`$` 元字符匹配字符串的结尾和每行的结尾（紧接在每个换行符之前）。

**`S`**

**`DOTALL`**

使 `'.'` 特殊字符匹配任何字符，包括换行符；没有这个标志，`'.'` 将匹配任何字符 *除了* 换行符。

**`A`**

**`ASCII`**

使 `\w`、`\W`、`\b`、`\B`、`\s` 和 `\S` 执行仅 ASCII 匹配而不是完整匹配 Unicode 匹配。 这仅对 Unicode 模式有意义，并且对于字节模式将被忽略。

**`X`**

**`VERBOSE`**

此标志允许你编写更易读的正则表达式，方法是为您提供更灵活的格式化方式。 指定此标志后，将忽略正则字符串中的空格，除非空格位于字符类中或前面带有未转义的反斜杠；这使你可以更清楚地组织和缩进正则。 此标志还允许你将注释放在正则中，引擎将忽略该注释；注释标记为 `'#'` 既不是在字符类中，也不是在未转义的反斜杠之前。

#### 更多元字符

其余一些元字符是  *零宽度断言* 。



























